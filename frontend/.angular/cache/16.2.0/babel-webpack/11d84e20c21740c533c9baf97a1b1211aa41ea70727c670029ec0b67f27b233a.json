{"ast":null,"code":"import { DataSource } from '@angular/cdk/collections';\nimport { map } from 'rxjs/operators';\nimport { of as observableOf, merge } from 'rxjs';\nconst EXAMPLE_DATA = [{\n  id: 1,\n  name: 'Hydrogen',\n  price: 9.99\n}, {\n  id: 2,\n  name: 'Helium',\n  price: 9.99\n}, {\n  id: 3,\n  name: 'Lithium',\n  price: 9.99\n}, {\n  id: 4,\n  name: 'Beryllium',\n  price: 9.99\n}, {\n  id: 5,\n  name: 'Boron',\n  price: 9.99\n}, {\n  id: 6,\n  name: 'Carbon',\n  price: 9.99\n}, {\n  id: 7,\n  name: 'Nitrogen',\n  price: 9.99\n}, {\n  id: 8,\n  name: 'Oxygen',\n  price: 9.99\n}, {\n  id: 9,\n  name: 'Fluorine',\n  price: 9.99\n}, {\n  id: 10,\n  name: 'Neon',\n  price: 9.99\n}, {\n  id: 11,\n  name: 'Sodium',\n  price: 9.99\n}, {\n  id: 12,\n  name: 'Magnesium',\n  price: 9.99\n}, {\n  id: 13,\n  name: 'Aluminum',\n  price: 9.99\n}, {\n  id: 14,\n  name: 'Silicon',\n  price: 9.99\n}, {\n  id: 15,\n  name: 'Phosphorus',\n  price: 9.99\n}, {\n  id: 16,\n  name: 'Sulfur',\n  price: 9.99\n}, {\n  id: 17,\n  name: 'Chlorine',\n  price: 9.99\n}, {\n  id: 18,\n  name: 'Argon',\n  price: 9.99\n}, {\n  id: 19,\n  name: 'Potassium',\n  price: 9.99\n}, {\n  id: 20,\n  name: 'Calcium',\n  price: 9.99\n}];\n/**\n * Data source for the ProductRead2 view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\nexport class ProductRead2DataSource extends DataSource {\n  constructor() {\n    super();\n    this.data = EXAMPLE_DATA;\n  }\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n  connect() {\n    // Combine everything that affects the rendered data into one update\n    // stream for the data-table to consume.\n    const dataMutations = [observableOf(this.data), this.paginator.page, this.sort.sortChange];\n    return merge(...dataMutations).pipe(map(() => {\n      return this.getPagedData(this.getSortedData([...this.data]));\n    }));\n  }\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n  disconnect() {}\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  getPagedData(data) {\n    const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n    return data.splice(startIndex, this.paginator.pageSize);\n  }\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  getSortedData(data) {\n    if (!this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n    return data.sort((a, b) => {\n      const isAsc = this.sort.direction === 'asc';\n      switch (this.sort.active) {\n        case 'name':\n          return compare(a.name, b.name, isAsc);\n        case 'id':\n          return compare(+a.id, +b.id, isAsc);\n        default:\n          return 0;\n      }\n    });\n  }\n}\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\nfunction compare(a, b, isAsc) {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}